// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: products.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addProductCategory = `-- name: AddProductCategory :exec
INSERT INTO product_categories (product_id, category_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AddProductCategoryParams struct {
	ProductID  pgtype.UUID `json:"product_id"`
	CategoryID pgtype.UUID `json:"category_id"`
}

func (q *Queries) AddProductCategory(ctx context.Context, arg AddProductCategoryParams) error {
	_, err := q.db.Exec(ctx, addProductCategory, arg.ProductID, arg.CategoryID)
	return err
}

const addProductCollection = `-- name: AddProductCollection :exec
INSERT INTO product_collections (product_id, collection_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AddProductCollectionParams struct {
	ProductID    pgtype.UUID `json:"product_id"`
	CollectionID pgtype.UUID `json:"collection_id"`
}

func (q *Queries) AddProductCollection(ctx context.Context, arg AddProductCollectionParams) error {
	_, err := q.db.Exec(ctx, addProductCollection, arg.ProductID, arg.CollectionID)
	return err
}

const clearProductCategories = `-- name: ClearProductCategories :exec
DELETE FROM product_categories WHERE product_id = $1
`

func (q *Queries) ClearProductCategories(ctx context.Context, productID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, clearProductCategories, productID)
	return err
}

const clearProductCollections = `-- name: ClearProductCollections :exec
DELETE FROM product_collections WHERE product_id = $1
`

func (q *Queries) ClearProductCollections(ctx context.Context, productID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, clearProductCollections, productID)
	return err
}

const countProducts = `-- name: CountProducts :one
SELECT COUNT(*) FROM products 
WHERE ($1::boolean IS NULL OR is_active = $1)
AND ($2::boolean IS NULL OR is_featured = $2)
`

type CountProductsParams struct {
	IsActive   *bool `json:"is_active"`
	IsFeatured *bool `json:"is_featured"`
}

func (q *Queries) CountProducts(ctx context.Context, arg CountProductsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProducts, arg.IsActive, arg.IsFeatured)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProductsWithCategoryFilter = `-- name: CountProductsWithCategoryFilter :one
SELECT COUNT(DISTINCT p.id) FROM products p
JOIN product_categories pc ON pc.product_id = p.id
JOIN categories c ON c.id = pc.category_id
WHERE c.slug = $1 
AND ($2::boolean IS NULL OR p.is_active = $2)
`

type CountProductsWithCategoryFilterParams struct {
	Slug     *string `json:"slug"`
	IsActive *bool   `json:"is_active"`
}

func (q *Queries) CountProductsWithCategoryFilter(ctx context.Context, arg CountProductsWithCategoryFilterParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProductsWithCategoryFilter, arg.Slug, arg.IsActive)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
    name, slug, description, base_price, sale_price, 
    stock_status, is_featured, is_active, 
    media, attributes, specifications, 
    meta_title, meta_description, meta_keywords, og_image,
    brand, tags, warranty_info
) VALUES (
    $1, $2, $3, $4, $5, 
    $6, $7, $8, 
    $9, $10, $11, 
    $12, $13, $14, $15,
    $16, $17, $18
) RETURNING id, name, slug, description, base_price, sale_price, stock_status, is_featured, is_active, media, attributes, specifications, created_at, updated_at, search_vector, meta_title, meta_description, meta_keywords, og_image, brand, tags, warranty_info
`

type CreateProductParams struct {
	Name            string         `json:"name"`
	Slug            string         `json:"slug"`
	Description     *string        `json:"description"`
	BasePrice       pgtype.Numeric `json:"base_price"`
	SalePrice       pgtype.Numeric `json:"sale_price"`
	StockStatus     *string        `json:"stock_status"`
	IsFeatured      bool           `json:"is_featured"`
	IsActive        bool           `json:"is_active"`
	Media           []byte         `json:"media"`
	Attributes      []byte         `json:"attributes"`
	Specifications  []byte         `json:"specifications"`
	MetaTitle       *string        `json:"meta_title"`
	MetaDescription *string        `json:"meta_description"`
	MetaKeywords    *string        `json:"meta_keywords"`
	OgImage         *string        `json:"og_image"`
	Brand           *string        `json:"brand"`
	Tags            []string       `json:"tags"`
	WarrantyInfo    []byte         `json:"warranty_info"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.BasePrice,
		arg.SalePrice,
		arg.StockStatus,
		arg.IsFeatured,
		arg.IsActive,
		arg.Media,
		arg.Attributes,
		arg.Specifications,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.MetaKeywords,
		arg.OgImage,
		arg.Brand,
		arg.Tags,
		arg.WarrantyInfo,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.BasePrice,
		&i.SalePrice,
		&i.StockStatus,
		&i.IsFeatured,
		&i.IsActive,
		&i.Media,
		&i.Attributes,
		&i.Specifications,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaKeywords,
		&i.OgImage,
		&i.Brand,
		&i.Tags,
		&i.WarrantyInfo,
	)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteProduct, id)
	return err
}

const getCategoryIDsForProduct = `-- name: GetCategoryIDsForProduct :many
SELECT category_id FROM product_categories WHERE product_id = $1
`

func (q *Queries) GetCategoryIDsForProduct(ctx context.Context, productID pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getCategoryIDsForProduct, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.UUID{}
	for rows.Next() {
		var category_id pgtype.UUID
		if err := rows.Scan(&category_id); err != nil {
			return nil, err
		}
		items = append(items, category_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryIDsForProducts = `-- name: GetCategoryIDsForProducts :many
SELECT product_id, category_id FROM product_categories WHERE product_id = ANY($1::uuid[])
`

func (q *Queries) GetCategoryIDsForProducts(ctx context.Context, dollar_1 []pgtype.UUID) ([]ProductCategory, error) {
	rows, err := q.db.Query(ctx, getCategoryIDsForProducts, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductCategory{}
	for rows.Next() {
		var i ProductCategory
		if err := rows.Scan(&i.ProductID, &i.CategoryID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionIDsForProduct = `-- name: GetCollectionIDsForProduct :many
SELECT collection_id FROM product_collections WHERE product_id = $1
`

func (q *Queries) GetCollectionIDsForProduct(ctx context.Context, productID pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getCollectionIDsForProduct, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.UUID{}
	for rows.Next() {
		var collection_id pgtype.UUID
		if err := rows.Scan(&collection_id); err != nil {
			return nil, err
		}
		items = append(items, collection_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionIDsForProducts = `-- name: GetCollectionIDsForProducts :many
SELECT product_id, collection_id FROM product_collections WHERE product_id = ANY($1::uuid[])
`

func (q *Queries) GetCollectionIDsForProducts(ctx context.Context, dollar_1 []pgtype.UUID) ([]ProductCollection, error) {
	rows, err := q.db.Query(ctx, getCollectionIDsForProducts, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductCollection{}
	for rows.Next() {
		var i ProductCollection
		if err := rows.Scan(&i.ProductID, &i.CollectionID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionsByIDs = `-- name: GetCollectionsByIDs :many
SELECT id, title, slug, description, image, story, is_active, created_at, updated_at, meta_title, meta_description, meta_keywords, og_image FROM collections WHERE id = ANY($1::uuid[])
`

func (q *Queries) GetCollectionsByIDs(ctx context.Context, dollar_1 []pgtype.UUID) ([]Collection, error) {
	rows, err := q.db.Query(ctx, getCollectionsByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Collection{}
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.Image,
			&i.Story,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.OgImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductByID = `-- name: GetProductByID :one
SELECT id, name, slug, description, base_price, sale_price, stock_status, is_featured, is_active, media, attributes, specifications, created_at, updated_at, search_vector, meta_title, meta_description, meta_keywords, og_image, brand, tags, warranty_info FROM products WHERE id = $1
`

func (q *Queries) GetProductByID(ctx context.Context, id pgtype.UUID) (Product, error) {
	row := q.db.QueryRow(ctx, getProductByID, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.BasePrice,
		&i.SalePrice,
		&i.StockStatus,
		&i.IsFeatured,
		&i.IsActive,
		&i.Media,
		&i.Attributes,
		&i.Specifications,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaKeywords,
		&i.OgImage,
		&i.Brand,
		&i.Tags,
		&i.WarrantyInfo,
	)
	return i, err
}

const getProductBySlug = `-- name: GetProductBySlug :one
SELECT id, name, slug, description, base_price, sale_price, stock_status, is_featured, is_active, media, attributes, specifications, created_at, updated_at, search_vector, meta_title, meta_description, meta_keywords, og_image, brand, tags, warranty_info FROM products WHERE slug = $1
`

func (q *Queries) GetProductBySlug(ctx context.Context, slug string) (Product, error) {
	row := q.db.QueryRow(ctx, getProductBySlug, slug)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.BasePrice,
		&i.SalePrice,
		&i.StockStatus,
		&i.IsFeatured,
		&i.IsActive,
		&i.Media,
		&i.Attributes,
		&i.Specifications,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaKeywords,
		&i.OgImage,
		&i.Brand,
		&i.Tags,
		&i.WarrantyInfo,
	)
	return i, err
}

const getProductStats = `-- name: GetProductStats :one
SELECT 
    COUNT(DISTINCT p.id) as total_products,
    COUNT(DISTINCT p.id) FILTER (WHERE p.is_active = true) as active_products,
    COUNT(DISTINCT p.id) FILTER (WHERE p.is_active = false) as inactive_products,
    COUNT(DISTINCT v.id) FILTER (WHERE v.stock = 0) as out_of_stock,
    COUNT(DISTINCT v.id) FILTER (WHERE v.stock > 0 AND v.stock <= v.low_stock_threshold) as low_stock,
    COALESCE(SUM(COALESCE(v.price, p.base_price) * v.stock), 0)::float8 as total_inventory_value
FROM products p
LEFT JOIN variants v ON v.product_id = p.id
`

type GetProductStatsRow struct {
	TotalProducts       int64   `json:"total_products"`
	ActiveProducts      int64   `json:"active_products"`
	InactiveProducts    int64   `json:"inactive_products"`
	OutOfStock          int64   `json:"out_of_stock"`
	LowStock            int64   `json:"low_stock"`
	TotalInventoryValue float64 `json:"total_inventory_value"`
}

func (q *Queries) GetProductStats(ctx context.Context) (GetProductStatsRow, error) {
	row := q.db.QueryRow(ctx, getProductStats)
	var i GetProductStatsRow
	err := row.Scan(
		&i.TotalProducts,
		&i.ActiveProducts,
		&i.InactiveProducts,
		&i.OutOfStock,
		&i.LowStock,
		&i.TotalInventoryValue,
	)
	return i, err
}

const getProducts = `-- name: GetProducts :many
SELECT id, name, slug, description, base_price, sale_price, stock_status, is_featured, is_active, media, attributes, specifications, created_at, updated_at, search_vector, meta_title, meta_description, meta_keywords, og_image, brand, tags, warranty_info FROM products 
WHERE ($3::boolean IS NULL OR is_active = $3)
AND ($4::boolean IS NULL OR is_featured = $4)
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type GetProductsParams struct {
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
	IsActive   *bool `json:"is_active"`
	IsFeatured *bool `json:"is_featured"`
}

func (q *Queries) GetProducts(ctx context.Context, arg GetProductsParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, getProducts,
		arg.Limit,
		arg.Offset,
		arg.IsActive,
		arg.IsFeatured,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.BasePrice,
			&i.SalePrice,
			&i.StockStatus,
			&i.IsFeatured,
			&i.IsActive,
			&i.Media,
			&i.Attributes,
			&i.Specifications,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.OgImage,
			&i.Brand,
			&i.Tags,
			&i.WarrantyInfo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsForCollection = `-- name: GetProductsForCollection :many
SELECT p.id, p.name, p.slug, p.description, p.base_price, p.sale_price, p.stock_status, p.is_featured, p.is_active, p.media, p.attributes, p.specifications, p.created_at, p.updated_at, p.search_vector, p.meta_title, p.meta_description, p.meta_keywords, p.og_image, p.brand, p.tags, p.warranty_info FROM products p
JOIN product_collections pc ON pc.product_id = p.id
WHERE pc.collection_id = $1 AND p.is_active = true
ORDER BY p.created_at DESC
`

func (q *Queries) GetProductsForCollection(ctx context.Context, collectionID pgtype.UUID) ([]Product, error) {
	rows, err := q.db.Query(ctx, getProductsForCollection, collectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.BasePrice,
			&i.SalePrice,
			&i.StockStatus,
			&i.IsFeatured,
			&i.IsActive,
			&i.Media,
			&i.Attributes,
			&i.Specifications,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.OgImage,
			&i.Brand,
			&i.Tags,
			&i.WarrantyInfo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsWithCategoryFilter = `-- name: GetProductsWithCategoryFilter :many
SELECT DISTINCT p.id, p.name, p.slug, p.description, p.base_price, p.sale_price, p.stock_status, p.is_featured, p.is_active, p.media, p.attributes, p.specifications, p.created_at, p.updated_at, p.search_vector, p.meta_title, p.meta_description, p.meta_keywords, p.og_image, p.brand, p.tags, p.warranty_info FROM products p
JOIN product_categories pc ON pc.product_id = p.id
JOIN categories c ON c.id = pc.category_id
WHERE c.slug = $1 
AND ($2::boolean IS NULL OR p.is_active = $2)
ORDER BY p.created_at DESC
LIMIT $4 OFFSET $3
`

type GetProductsWithCategoryFilterParams struct {
	Slug     *string `json:"slug"`
	IsActive *bool   `json:"is_active"`
	Offset   int32   `json:"offset"`
	Limit    int32   `json:"limit"`
}

func (q *Queries) GetProductsWithCategoryFilter(ctx context.Context, arg GetProductsWithCategoryFilterParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, getProductsWithCategoryFilter,
		arg.Slug,
		arg.IsActive,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.BasePrice,
			&i.SalePrice,
			&i.StockStatus,
			&i.IsFeatured,
			&i.IsActive,
			&i.Media,
			&i.Attributes,
			&i.Specifications,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.OgImage,
			&i.Brand,
			&i.Tags,
			&i.WarrantyInfo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsWithPriceRange = `-- name: GetProductsWithPriceRange :many
SELECT id, name, slug, description, base_price, sale_price, stock_status, is_featured, is_active, media, attributes, specifications, created_at, updated_at, search_vector, meta_title, meta_description, meta_keywords, og_image, brand, tags, warranty_info FROM products
WHERE base_price >= $1 AND base_price <= $2 AND ($3::boolean IS NULL OR is_active = $3)
ORDER BY created_at DESC
LIMIT $4 OFFSET $5
`

type GetProductsWithPriceRangeParams struct {
	BasePrice   pgtype.Numeric `json:"base_price"`
	BasePrice_2 pgtype.Numeric `json:"base_price_2"`
	Column3     bool           `json:"column_3"`
	Limit       int32          `json:"limit"`
	Offset      int32          `json:"offset"`
}

func (q *Queries) GetProductsWithPriceRange(ctx context.Context, arg GetProductsWithPriceRangeParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, getProductsWithPriceRange,
		arg.BasePrice,
		arg.BasePrice_2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.BasePrice,
			&i.SalePrice,
			&i.StockStatus,
			&i.IsFeatured,
			&i.IsActive,
			&i.Media,
			&i.Attributes,
			&i.Specifications,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.OgImage,
			&i.Brand,
			&i.Tags,
			&i.WarrantyInfo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeProductCategory = `-- name: RemoveProductCategory :exec
DELETE FROM product_categories WHERE product_id = $1 AND category_id = $2
`

type RemoveProductCategoryParams struct {
	ProductID  pgtype.UUID `json:"product_id"`
	CategoryID pgtype.UUID `json:"category_id"`
}

func (q *Queries) RemoveProductCategory(ctx context.Context, arg RemoveProductCategoryParams) error {
	_, err := q.db.Exec(ctx, removeProductCategory, arg.ProductID, arg.CategoryID)
	return err
}

const removeProductCollection = `-- name: RemoveProductCollection :exec
DELETE FROM product_collections WHERE product_id = $1 AND collection_id = $2
`

type RemoveProductCollectionParams struct {
	ProductID    pgtype.UUID `json:"product_id"`
	CollectionID pgtype.UUID `json:"collection_id"`
}

func (q *Queries) RemoveProductCollection(ctx context.Context, arg RemoveProductCollectionParams) error {
	_, err := q.db.Exec(ctx, removeProductCollection, arg.ProductID, arg.CollectionID)
	return err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET name = $2, slug = $3, description = $4, base_price = $5, sale_price = $6, 
    stock_status = $7, is_featured = $8, 
    is_active = $9, media = $10, attributes = $11, specifications = $12,
    meta_title = $13, meta_description = $14, meta_keywords = $15, og_image = $16,
    brand = $17, tags = $18, warranty_info = $19
WHERE id = $1
RETURNING id, name, slug, description, base_price, sale_price, stock_status, is_featured, is_active, media, attributes, specifications, created_at, updated_at, search_vector, meta_title, meta_description, meta_keywords, og_image, brand, tags, warranty_info
`

type UpdateProductParams struct {
	ID              pgtype.UUID    `json:"id"`
	Name            string         `json:"name"`
	Slug            string         `json:"slug"`
	Description     *string        `json:"description"`
	BasePrice       pgtype.Numeric `json:"base_price"`
	SalePrice       pgtype.Numeric `json:"sale_price"`
	StockStatus     *string        `json:"stock_status"`
	IsFeatured      bool           `json:"is_featured"`
	IsActive        bool           `json:"is_active"`
	Media           []byte         `json:"media"`
	Attributes      []byte         `json:"attributes"`
	Specifications  []byte         `json:"specifications"`
	MetaTitle       *string        `json:"meta_title"`
	MetaDescription *string        `json:"meta_description"`
	MetaKeywords    *string        `json:"meta_keywords"`
	OgImage         *string        `json:"og_image"`
	Brand           *string        `json:"brand"`
	Tags            []string       `json:"tags"`
	WarrantyInfo    []byte         `json:"warranty_info"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.BasePrice,
		arg.SalePrice,
		arg.StockStatus,
		arg.IsFeatured,
		arg.IsActive,
		arg.Media,
		arg.Attributes,
		arg.Specifications,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.MetaKeywords,
		arg.OgImage,
		arg.Brand,
		arg.Tags,
		arg.WarrantyInfo,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.BasePrice,
		&i.SalePrice,
		&i.StockStatus,
		&i.IsFeatured,
		&i.IsActive,
		&i.Media,
		&i.Attributes,
		&i.Specifications,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaKeywords,
		&i.OgImage,
		&i.Brand,
		&i.Tags,
		&i.WarrantyInfo,
	)
	return i, err
}

const updateProductStatus = `-- name: UpdateProductStatus :exec
UPDATE products SET is_active = $2 WHERE id = $1
`

type UpdateProductStatusParams struct {
	ID       pgtype.UUID `json:"id"`
	IsActive bool        `json:"is_active"`
}

func (q *Queries) UpdateProductStatus(ctx context.Context, arg UpdateProductStatusParams) error {
	_, err := q.db.Exec(ctx, updateProductStatus, arg.ID, arg.IsActive)
	return err
}
