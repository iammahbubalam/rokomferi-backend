// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: wishlist.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addWishlistItem = `-- name: AddWishlistItem :exec
INSERT INTO wishlist_items (wishlist_id, product_id) 
VALUES ($1, $2)
ON CONFLICT (wishlist_id, product_id) DO NOTHING
`

type AddWishlistItemParams struct {
	WishlistID pgtype.UUID `json:"wishlist_id"`
	ProductID  pgtype.UUID `json:"product_id"`
}

func (q *Queries) AddWishlistItem(ctx context.Context, arg AddWishlistItemParams) error {
	_, err := q.db.Exec(ctx, addWishlistItem, arg.WishlistID, arg.ProductID)
	return err
}

const checkItemInWishlist = `-- name: CheckItemInWishlist :one
SELECT EXISTS(
    SELECT 1 FROM wishlist_items 
    WHERE wishlist_id = $1 AND product_id = $2
)
`

type CheckItemInWishlistParams struct {
	WishlistID pgtype.UUID `json:"wishlist_id"`
	ProductID  pgtype.UUID `json:"product_id"`
}

func (q *Queries) CheckItemInWishlist(ctx context.Context, arg CheckItemInWishlistParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkItemInWishlist, arg.WishlistID, arg.ProductID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createWishlist = `-- name: CreateWishlist :one
INSERT INTO wishlists (user_id) VALUES ($1) RETURNING id, user_id, created_at, updated_at
`

func (q *Queries) CreateWishlist(ctx context.Context, userID pgtype.UUID) (Wishlist, error) {
	row := q.db.QueryRow(ctx, createWishlist, userID)
	var i Wishlist
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWishlistByUserID = `-- name: GetWishlistByUserID :one
SELECT id, user_id, created_at, updated_at FROM wishlists WHERE user_id = $1
`

func (q *Queries) GetWishlistByUserID(ctx context.Context, userID pgtype.UUID) (Wishlist, error) {
	row := q.db.QueryRow(ctx, getWishlistByUserID, userID)
	var i Wishlist
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWishlistItems = `-- name: GetWishlistItems :many
SELECT 
    wi.id as wishlist_item_id,
    wi.product_id,
    wi.created_at as added_at,
    p.name,
    p.slug,
    p.base_price,
    p.sale_price,
    p.media,
    COALESCE(SUM(v.stock), 0)::int as total_stock
FROM wishlist_items wi
JOIN products p ON wi.product_id = p.id
LEFT JOIN variants v ON v.product_id = p.id
WHERE wi.wishlist_id = $1
GROUP BY wi.id, wi.product_id, wi.created_at, p.name, p.slug, p.base_price, p.sale_price, p.media
ORDER BY wi.created_at DESC
`

type GetWishlistItemsRow struct {
	WishlistItemID pgtype.UUID      `json:"wishlist_item_id"`
	ProductID      pgtype.UUID      `json:"product_id"`
	AddedAt        pgtype.Timestamp `json:"added_at"`
	Name           string           `json:"name"`
	Slug           string           `json:"slug"`
	BasePrice      pgtype.Numeric   `json:"base_price"`
	SalePrice      pgtype.Numeric   `json:"sale_price"`
	Media          []byte           `json:"media"`
	TotalStock     int32            `json:"total_stock"`
}

func (q *Queries) GetWishlistItems(ctx context.Context, wishlistID pgtype.UUID) ([]GetWishlistItemsRow, error) {
	rows, err := q.db.Query(ctx, getWishlistItems, wishlistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWishlistItemsRow{}
	for rows.Next() {
		var i GetWishlistItemsRow
		if err := rows.Scan(
			&i.WishlistItemID,
			&i.ProductID,
			&i.AddedAt,
			&i.Name,
			&i.Slug,
			&i.BasePrice,
			&i.SalePrice,
			&i.Media,
			&i.TotalStock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeWishlistItem = `-- name: RemoveWishlistItem :exec
DELETE FROM wishlist_items 
WHERE wishlist_id = $1 AND product_id = $2
`

type RemoveWishlistItemParams struct {
	WishlistID pgtype.UUID `json:"wishlist_id"`
	ProductID  pgtype.UUID `json:"product_id"`
}

func (q *Queries) RemoveWishlistItem(ctx context.Context, arg RemoveWishlistItemParams) error {
	_, err := q.db.Exec(ctx, removeWishlistItem, arg.WishlistID, arg.ProductID)
	return err
}
