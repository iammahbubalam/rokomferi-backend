// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: content.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getActiveContentBlock = `-- name: GetActiveContentBlock :one
SELECT id, section_key, content, created_at, updated_at, start_at, end_at, is_active FROM content_blocks 
WHERE section_key = $1 
  AND is_active = true 
  AND (start_at IS NULL OR start_at <= NOW())
  AND (end_at IS NULL OR end_at > NOW())
`

func (q *Queries) GetActiveContentBlock(ctx context.Context, sectionKey string) (ContentBlock, error) {
	row := q.db.QueryRow(ctx, getActiveContentBlock, sectionKey)
	var i ContentBlock
	err := row.Scan(
		&i.ID,
		&i.SectionKey,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartAt,
		&i.EndAt,
		&i.IsActive,
	)
	return i, err
}

const getContentBlockByKey = `-- name: GetContentBlockByKey :one
SELECT id, section_key, content, created_at, updated_at, start_at, end_at, is_active FROM content_blocks WHERE section_key = $1
`

func (q *Queries) GetContentBlockByKey(ctx context.Context, sectionKey string) (ContentBlock, error) {
	row := q.db.QueryRow(ctx, getContentBlockByKey, sectionKey)
	var i ContentBlock
	err := row.Scan(
		&i.ID,
		&i.SectionKey,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartAt,
		&i.EndAt,
		&i.IsActive,
	)
	return i, err
}

const updateContentBlockSchedule = `-- name: UpdateContentBlockSchedule :exec
UPDATE content_blocks 
SET start_at = $2, end_at = $3, is_active = $4
WHERE section_key = $1
`

type UpdateContentBlockScheduleParams struct {
	SectionKey string           `json:"section_key"`
	StartAt    pgtype.Timestamp `json:"start_at"`
	EndAt      pgtype.Timestamp `json:"end_at"`
	IsActive   *bool            `json:"is_active"`
}

func (q *Queries) UpdateContentBlockSchedule(ctx context.Context, arg UpdateContentBlockScheduleParams) error {
	_, err := q.db.Exec(ctx, updateContentBlockSchedule,
		arg.SectionKey,
		arg.StartAt,
		arg.EndAt,
		arg.IsActive,
	)
	return err
}

const upsertContentBlock = `-- name: UpsertContentBlock :one
INSERT INTO content_blocks (section_key, content)
VALUES ($1, $2)
ON CONFLICT (section_key) DO UPDATE
SET content = EXCLUDED.content,
    updated_at = NOW()
RETURNING id, section_key, content, created_at, updated_at, start_at, end_at, is_active
`

type UpsertContentBlockParams struct {
	SectionKey string `json:"section_key"`
	Content    []byte `json:"content"`
}

func (q *Queries) UpsertContentBlock(ctx context.Context, arg UpsertContentBlockParams) (ContentBlock, error) {
	row := q.db.QueryRow(ctx, upsertContentBlock, arg.SectionKey, arg.Content)
	var i ContentBlock
	err := row.Scan(
		&i.ID,
		&i.SectionKey,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartAt,
		&i.EndAt,
		&i.IsActive,
	)
	return i, err
}
