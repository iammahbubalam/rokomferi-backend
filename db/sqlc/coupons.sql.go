// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: coupons.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countCoupons = `-- name: CountCoupons :one
SELECT COUNT(*) FROM coupons
`

func (q *Queries) CountCoupons(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countCoupons)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCoupon = `-- name: CreateCoupon :one
INSERT INTO coupons (code, type, value, min_spend, usage_limit, start_at, expires_at, is_active)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, code, type, value, min_spend, usage_limit, used_count, start_at, expires_at, is_active, created_at, updated_at
`

type CreateCouponParams struct {
	Code       string           `json:"code"`
	Type       string           `json:"type"`
	Value      pgtype.Numeric   `json:"value"`
	MinSpend   pgtype.Numeric   `json:"min_spend"`
	UsageLimit *int32           `json:"usage_limit"`
	StartAt    pgtype.Timestamp `json:"start_at"`
	ExpiresAt  pgtype.Timestamp `json:"expires_at"`
	IsActive   *bool            `json:"is_active"`
}

func (q *Queries) CreateCoupon(ctx context.Context, arg CreateCouponParams) (Coupon, error) {
	row := q.db.QueryRow(ctx, createCoupon,
		arg.Code,
		arg.Type,
		arg.Value,
		arg.MinSpend,
		arg.UsageLimit,
		arg.StartAt,
		arg.ExpiresAt,
		arg.IsActive,
	)
	var i Coupon
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Type,
		&i.Value,
		&i.MinSpend,
		&i.UsageLimit,
		&i.UsedCount,
		&i.StartAt,
		&i.ExpiresAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCoupon = `-- name: DeleteCoupon :exec
DELETE FROM coupons WHERE id = $1
`

func (q *Queries) DeleteCoupon(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteCoupon, id)
	return err
}

const getCouponByCode = `-- name: GetCouponByCode :one
SELECT id, code, type, value, min_spend, usage_limit, used_count, start_at, expires_at, is_active, created_at, updated_at FROM coupons 
WHERE code = $1
`

func (q *Queries) GetCouponByCode(ctx context.Context, code string) (Coupon, error) {
	row := q.db.QueryRow(ctx, getCouponByCode, code)
	var i Coupon
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Type,
		&i.Value,
		&i.MinSpend,
		&i.UsageLimit,
		&i.UsedCount,
		&i.StartAt,
		&i.ExpiresAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCouponByID = `-- name: GetCouponByID :one
SELECT id, code, type, value, min_spend, usage_limit, used_count, start_at, expires_at, is_active, created_at, updated_at FROM coupons WHERE id = $1
`

func (q *Queries) GetCouponByID(ctx context.Context, id pgtype.UUID) (Coupon, error) {
	row := q.db.QueryRow(ctx, getCouponByID, id)
	var i Coupon
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Type,
		&i.Value,
		&i.MinSpend,
		&i.UsageLimit,
		&i.UsedCount,
		&i.StartAt,
		&i.ExpiresAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const incrementCouponUsage = `-- name: IncrementCouponUsage :exec
UPDATE coupons 
SET used_count = used_count + 1 
WHERE id = $1 AND (usage_limit = 0 OR used_count < usage_limit)
`

// L9 Optimization: Atomic increment with optimistic concurrency check if needed.
// We rely on db-level atomicity here.
func (q *Queries) IncrementCouponUsage(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, incrementCouponUsage, id)
	return err
}

const listCoupons = `-- name: ListCoupons :many
SELECT id, code, type, value, min_spend, usage_limit, used_count, start_at, expires_at, is_active, created_at, updated_at FROM coupons 
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListCouponsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListCoupons(ctx context.Context, arg ListCouponsParams) ([]Coupon, error) {
	rows, err := q.db.Query(ctx, listCoupons, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Coupon{}
	for rows.Next() {
		var i Coupon
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Type,
			&i.Value,
			&i.MinSpend,
			&i.UsageLimit,
			&i.UsedCount,
			&i.StartAt,
			&i.ExpiresAt,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCoupon = `-- name: UpdateCoupon :exec
UPDATE coupons SET 
    code = $2,
    type = $3,
    value = $4,
    min_spend = $5,
    usage_limit = $6,
    start_at = $7,
    expires_at = $8,
    is_active = $9
WHERE id = $1
`

type UpdateCouponParams struct {
	ID         pgtype.UUID      `json:"id"`
	Code       string           `json:"code"`
	Type       string           `json:"type"`
	Value      pgtype.Numeric   `json:"value"`
	MinSpend   pgtype.Numeric   `json:"min_spend"`
	UsageLimit *int32           `json:"usage_limit"`
	StartAt    pgtype.Timestamp `json:"start_at"`
	ExpiresAt  pgtype.Timestamp `json:"expires_at"`
	IsActive   *bool            `json:"is_active"`
}

func (q *Queries) UpdateCoupon(ctx context.Context, arg UpdateCouponParams) error {
	_, err := q.db.Exec(ctx, updateCoupon,
		arg.ID,
		arg.Code,
		arg.Type,
		arg.Value,
		arg.MinSpend,
		arg.UsageLimit,
		arg.StartAt,
		arg.ExpiresAt,
		arg.IsActive,
	)
	return err
}

const validateCoupon = `-- name: ValidateCoupon :one
SELECT 
    id, 
    code, 
    type, 
    value, 
    min_spend,
    CASE 
        WHEN NOT is_active THEN 'inactive'
        WHEN start_at > NOW() THEN 'not_started'
        WHEN expires_at < NOW() THEN 'expired'
        WHEN usage_limit > 0 AND used_count >= usage_limit THEN 'fully_redeemed'
        WHEN min_spend > $1::decimal THEN 'min_spend_not_met'
        ELSE 'valid'
    END::text as validation_status
FROM coupons 
WHERE code = $2
`

type ValidateCouponParams struct {
	CartTotal pgtype.Numeric `json:"cart_total"`
	Code      string         `json:"code"`
}

type ValidateCouponRow struct {
	ID               pgtype.UUID    `json:"id"`
	Code             string         `json:"code"`
	Type             string         `json:"type"`
	Value            pgtype.Numeric `json:"value"`
	MinSpend         pgtype.Numeric `json:"min_spend"`
	ValidationStatus string         `json:"validation_status"`
}

// L9 Optimization: Single-pass validation logic pushed to DB.
// Returns the coupon if valid, or a status reason if not.
// Uses covering indexes on (code) and partial indexes on (is_active) where applicable.
func (q *Queries) ValidateCoupon(ctx context.Context, arg ValidateCouponParams) (ValidateCouponRow, error) {
	row := q.db.QueryRow(ctx, validateCoupon, arg.CartTotal, arg.Code)
	var i ValidateCouponRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Type,
		&i.Value,
		&i.MinSpend,
		&i.ValidationStatus,
	)
	return i, err
}
