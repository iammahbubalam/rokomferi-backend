// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: variants.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAllVariantsWithProduct = `-- name: CountAllVariantsWithProduct :one
SELECT COUNT(*) FROM variants v
JOIN products p ON v.product_id = p.id
WHERE 
    ($1::uuid IS NULL OR v.product_id = $1)
    AND ($2::boolean = false OR v.stock <= v.low_stock_threshold)
    AND ($3::text = '' OR v.sku ILIKE '%' || $3 || '%' OR v.name ILIKE '%' || $3 || '%' OR p.name ILIKE '%' || $3 || '%')
`

type CountAllVariantsWithProductParams struct {
	Column1 pgtype.UUID `json:"column_1"`
	Column2 bool        `json:"column_2"`
	Column3 string      `json:"column_3"`
}

func (q *Queries) CountAllVariantsWithProduct(ctx context.Context, arg CountAllVariantsWithProductParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAllVariantsWithProduct, arg.Column1, arg.Column2, arg.Column3)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countInventoryLogs = `-- name: CountInventoryLogs :one
SELECT COUNT(*) FROM inventory_logs WHERE ($1::uuid IS NULL OR product_id = $1)
`

func (q *Queries) CountInventoryLogs(ctx context.Context, dollar_1 pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countInventoryLogs, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInventoryLog = `-- name: CreateInventoryLog :one
INSERT INTO inventory_logs (product_id, variant_id, change_amount, reason, reference_id)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, product_id, variant_id, change_amount, reason, reference_id, created_at
`

type CreateInventoryLogParams struct {
	ProductID    pgtype.UUID `json:"product_id"`
	VariantID    pgtype.UUID `json:"variant_id"`
	ChangeAmount int32       `json:"change_amount"`
	Reason       string      `json:"reason"`
	ReferenceID  string      `json:"reference_id"`
}

func (q *Queries) CreateInventoryLog(ctx context.Context, arg CreateInventoryLogParams) (InventoryLog, error) {
	row := q.db.QueryRow(ctx, createInventoryLog,
		arg.ProductID,
		arg.VariantID,
		arg.ChangeAmount,
		arg.Reason,
		arg.ReferenceID,
	)
	var i InventoryLog
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.VariantID,
		&i.ChangeAmount,
		&i.Reason,
		&i.ReferenceID,
		&i.CreatedAt,
	)
	return i, err
}

const createVariant = `-- name: CreateVariant :one
INSERT INTO variants (
    product_id, name, stock, sku, 
    attributes, price, sale_price, images, weight, dimensions, barcode, 
    low_stock_threshold
) VALUES (
    $1, $2, $3, $4, 
    $5, $6, $7, $8, $9, $10, $11,
    $12
) RETURNING id, product_id, name, stock, sku, attributes, price, sale_price, images, weight, dimensions, barcode, low_stock_threshold, created_at, updated_at
`

type CreateVariantParams struct {
	ProductID         pgtype.UUID    `json:"product_id"`
	Name              string         `json:"name"`
	Stock             int32          `json:"stock"`
	Sku               *string        `json:"sku"`
	Attributes        []byte         `json:"attributes"`
	Price             pgtype.Numeric `json:"price"`
	SalePrice         pgtype.Numeric `json:"sale_price"`
	Images            []string       `json:"images"`
	Weight            pgtype.Numeric `json:"weight"`
	Dimensions        []byte         `json:"dimensions"`
	Barcode           *string        `json:"barcode"`
	LowStockThreshold int32          `json:"low_stock_threshold"`
}

func (q *Queries) CreateVariant(ctx context.Context, arg CreateVariantParams) (Variant, error) {
	row := q.db.QueryRow(ctx, createVariant,
		arg.ProductID,
		arg.Name,
		arg.Stock,
		arg.Sku,
		arg.Attributes,
		arg.Price,
		arg.SalePrice,
		arg.Images,
		arg.Weight,
		arg.Dimensions,
		arg.Barcode,
		arg.LowStockThreshold,
	)
	var i Variant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Name,
		&i.Stock,
		&i.Sku,
		&i.Attributes,
		&i.Price,
		&i.SalePrice,
		&i.Images,
		&i.Weight,
		&i.Dimensions,
		&i.Barcode,
		&i.LowStockThreshold,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteVariant = `-- name: DeleteVariant :exec
DELETE FROM variants WHERE id = $1
`

func (q *Queries) DeleteVariant(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteVariant, id)
	return err
}

const deleteVariantsByProductID = `-- name: DeleteVariantsByProductID :exec
DELETE FROM variants WHERE product_id = $1
`

func (q *Queries) DeleteVariantsByProductID(ctx context.Context, productID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteVariantsByProductID, productID)
	return err
}

const getAllVariantsWithProduct = `-- name: GetAllVariantsWithProduct :many
SELECT 
    v.id,
    v.product_id,
    v.name,
    v.stock,
    v.sku,
    v.attributes,
    v.price,
    v.sale_price,
    v.images,
    v.weight,
    v.dimensions,
    v.barcode,
    v.low_stock_threshold,
    v.created_at,
    v.updated_at,
    p.name AS product_name,
    p.slug AS product_slug,
    p.base_price AS product_base_price,
    p.media AS product_media
FROM variants v
JOIN products p ON v.product_id = p.id
WHERE 
    ($1::uuid IS NULL OR v.product_id = $1)
    AND ($2::boolean = false OR v.stock <= v.low_stock_threshold)
    AND ($3::text = '' OR v.sku ILIKE '%' || $3 || '%' OR v.name ILIKE '%' || $3 || '%' OR p.name ILIKE '%' || $3 || '%')
ORDER BY 
    CASE WHEN $4 = 'stock_asc' THEN v.stock END ASC,
    CASE WHEN $4 = 'stock_desc' THEN v.stock END DESC,
    CASE WHEN $4 = 'sku_asc' THEN v.sku END ASC,
    CASE WHEN $4 = '' OR $4 IS NULL THEN v.created_at END DESC
LIMIT $5 OFFSET $6
`

type GetAllVariantsWithProductParams struct {
	Column1 pgtype.UUID `json:"column_1"`
	Column2 bool        `json:"column_2"`
	Column3 string      `json:"column_3"`
	Column4 interface{} `json:"column_4"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type GetAllVariantsWithProductRow struct {
	ID                pgtype.UUID      `json:"id"`
	ProductID         pgtype.UUID      `json:"product_id"`
	Name              string           `json:"name"`
	Stock             int32            `json:"stock"`
	Sku               *string          `json:"sku"`
	Attributes        []byte           `json:"attributes"`
	Price             pgtype.Numeric   `json:"price"`
	SalePrice         pgtype.Numeric   `json:"sale_price"`
	Images            []string         `json:"images"`
	Weight            pgtype.Numeric   `json:"weight"`
	Dimensions        []byte           `json:"dimensions"`
	Barcode           *string          `json:"barcode"`
	LowStockThreshold int32            `json:"low_stock_threshold"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	UpdatedAt         pgtype.Timestamp `json:"updated_at"`
	ProductName       string           `json:"product_name"`
	ProductSlug       string           `json:"product_slug"`
	ProductBasePrice  pgtype.Numeric   `json:"product_base_price"`
	ProductMedia      []byte           `json:"product_media"`
}

func (q *Queries) GetAllVariantsWithProduct(ctx context.Context, arg GetAllVariantsWithProductParams) ([]GetAllVariantsWithProductRow, error) {
	rows, err := q.db.Query(ctx, getAllVariantsWithProduct,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllVariantsWithProductRow{}
	for rows.Next() {
		var i GetAllVariantsWithProductRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Name,
			&i.Stock,
			&i.Sku,
			&i.Attributes,
			&i.Price,
			&i.SalePrice,
			&i.Images,
			&i.Weight,
			&i.Dimensions,
			&i.Barcode,
			&i.LowStockThreshold,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.ProductSlug,
			&i.ProductBasePrice,
			&i.ProductMedia,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryLogs = `-- name: GetInventoryLogs :many
SELECT id, product_id, variant_id, change_amount, reason, reference_id, created_at FROM inventory_logs 
WHERE ($1::uuid IS NULL OR product_id = $1)
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetInventoryLogsParams struct {
	Column1 pgtype.UUID `json:"column_1"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

func (q *Queries) GetInventoryLogs(ctx context.Context, arg GetInventoryLogsParams) ([]InventoryLog, error) {
	rows, err := q.db.Query(ctx, getInventoryLogs, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InventoryLog{}
	for rows.Next() {
		var i InventoryLog
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.VariantID,
			&i.ChangeAmount,
			&i.Reason,
			&i.ReferenceID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVariantByID = `-- name: GetVariantByID :one
SELECT id, product_id, name, stock, sku, attributes, price, sale_price, images, weight, dimensions, barcode, low_stock_threshold, created_at, updated_at FROM variants WHERE id = $1
`

func (q *Queries) GetVariantByID(ctx context.Context, id pgtype.UUID) (Variant, error) {
	row := q.db.QueryRow(ctx, getVariantByID, id)
	var i Variant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Name,
		&i.Stock,
		&i.Sku,
		&i.Attributes,
		&i.Price,
		&i.SalePrice,
		&i.Images,
		&i.Weight,
		&i.Dimensions,
		&i.Barcode,
		&i.LowStockThreshold,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVariantsByProductID = `-- name: GetVariantsByProductID :many
SELECT id, product_id, name, stock, sku, attributes, price, sale_price, images, weight, dimensions, barcode, low_stock_threshold, created_at, updated_at FROM variants WHERE product_id = $1
`

func (q *Queries) GetVariantsByProductID(ctx context.Context, productID pgtype.UUID) ([]Variant, error) {
	rows, err := q.db.Query(ctx, getVariantsByProductID, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Variant{}
	for rows.Next() {
		var i Variant
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Name,
			&i.Stock,
			&i.Sku,
			&i.Attributes,
			&i.Price,
			&i.SalePrice,
			&i.Images,
			&i.Weight,
			&i.Dimensions,
			&i.Barcode,
			&i.LowStockThreshold,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVariantsByProductIDs = `-- name: GetVariantsByProductIDs :many
SELECT id, product_id, name, stock, sku, attributes, price, sale_price, images, weight, dimensions, barcode, low_stock_threshold, created_at, updated_at FROM variants WHERE product_id = ANY($1::uuid[])
`

func (q *Queries) GetVariantsByProductIDs(ctx context.Context, dollar_1 []pgtype.UUID) ([]Variant, error) {
	rows, err := q.db.Query(ctx, getVariantsByProductIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Variant{}
	for rows.Next() {
		var i Variant
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Name,
			&i.Stock,
			&i.Sku,
			&i.Attributes,
			&i.Price,
			&i.SalePrice,
			&i.Images,
			&i.Weight,
			&i.Dimensions,
			&i.Barcode,
			&i.LowStockThreshold,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVariant = `-- name: UpdateVariant :one
UPDATE variants 
SET name = $2, stock = $3, sku = $4,
    attributes = $5, price = $6, sale_price = $7, 
    images = $8, weight = $9, dimensions = $10, barcode = $11,
    low_stock_threshold = $12
WHERE id = $1 
RETURNING id, product_id, name, stock, sku, attributes, price, sale_price, images, weight, dimensions, barcode, low_stock_threshold, created_at, updated_at
`

type UpdateVariantParams struct {
	ID                pgtype.UUID    `json:"id"`
	Name              string         `json:"name"`
	Stock             int32          `json:"stock"`
	Sku               *string        `json:"sku"`
	Attributes        []byte         `json:"attributes"`
	Price             pgtype.Numeric `json:"price"`
	SalePrice         pgtype.Numeric `json:"sale_price"`
	Images            []string       `json:"images"`
	Weight            pgtype.Numeric `json:"weight"`
	Dimensions        []byte         `json:"dimensions"`
	Barcode           *string        `json:"barcode"`
	LowStockThreshold int32          `json:"low_stock_threshold"`
}

func (q *Queries) UpdateVariant(ctx context.Context, arg UpdateVariantParams) (Variant, error) {
	row := q.db.QueryRow(ctx, updateVariant,
		arg.ID,
		arg.Name,
		arg.Stock,
		arg.Sku,
		arg.Attributes,
		arg.Price,
		arg.SalePrice,
		arg.Images,
		arg.Weight,
		arg.Dimensions,
		arg.Barcode,
		arg.LowStockThreshold,
	)
	var i Variant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Name,
		&i.Stock,
		&i.Sku,
		&i.Attributes,
		&i.Price,
		&i.SalePrice,
		&i.Images,
		&i.Weight,
		&i.Dimensions,
		&i.Barcode,
		&i.LowStockThreshold,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateVariantStock = `-- name: UpdateVariantStock :execrows
UPDATE variants SET stock = stock + $2 WHERE id = $1 AND stock + $2 >= 0
`

type UpdateVariantStockParams struct {
	ID    pgtype.UUID `json:"id"`
	Stock int32       `json:"stock"`
}

func (q *Queries) UpdateVariantStock(ctx context.Context, arg UpdateVariantStockParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateVariantStock, arg.ID, arg.Stock)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
