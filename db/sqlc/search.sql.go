// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: search.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countSearchProducts = `-- name: CountSearchProducts :one
SELECT COUNT(*)
FROM products
WHERE search_vector @@ websearch_to_tsquery('english', $1)
  AND ($2::boolean IS NULL OR is_active = $2)
`

type CountSearchProductsParams struct {
	Query    string `json:"query"`
	IsActive *bool  `json:"is_active"`
}

func (q *Queries) CountSearchProducts(ctx context.Context, arg CountSearchProductsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchProducts, arg.Query, arg.IsActive)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const searchProducts = `-- name: SearchProducts :many
SELECT id, name, slug, description, base_price, sale_price, stock_status, is_featured, is_active, media, attributes, specifications, created_at, updated_at, search_vector, meta_title, meta_description, meta_keywords, og_image, brand, tags, warranty_info,
       ts_rank(search_vector, websearch_to_tsquery('english', $3)) as rank
FROM products
WHERE search_vector @@ websearch_to_tsquery('english', $3)
  AND ($4::boolean IS NULL OR is_active = $4)
ORDER BY rank DESC, created_at DESC
LIMIT $1 OFFSET $2
`

type SearchProductsParams struct {
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
	Query    string `json:"query"`
	IsActive *bool  `json:"is_active"`
}

type SearchProductsRow struct {
	ID              pgtype.UUID      `json:"id"`
	Name            string           `json:"name"`
	Slug            string           `json:"slug"`
	Description     *string          `json:"description"`
	BasePrice       pgtype.Numeric   `json:"base_price"`
	SalePrice       pgtype.Numeric   `json:"sale_price"`
	StockStatus     *string          `json:"stock_status"`
	IsFeatured      bool             `json:"is_featured"`
	IsActive        bool             `json:"is_active"`
	Media           []byte           `json:"media"`
	Attributes      []byte           `json:"attributes"`
	Specifications  []byte           `json:"specifications"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	UpdatedAt       pgtype.Timestamp `json:"updated_at"`
	SearchVector    interface{}      `json:"search_vector"`
	MetaTitle       *string          `json:"meta_title"`
	MetaDescription *string          `json:"meta_description"`
	MetaKeywords    *string          `json:"meta_keywords"`
	OgImage         *string          `json:"og_image"`
	Brand           *string          `json:"brand"`
	Tags            []string         `json:"tags"`
	WarrantyInfo    []byte           `json:"warranty_info"`
	Rank            float32          `json:"rank"`
}

func (q *Queries) SearchProducts(ctx context.Context, arg SearchProductsParams) ([]SearchProductsRow, error) {
	rows, err := q.db.Query(ctx, searchProducts,
		arg.Limit,
		arg.Offset,
		arg.Query,
		arg.IsActive,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchProductsRow{}
	for rows.Next() {
		var i SearchProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.BasePrice,
			&i.SalePrice,
			&i.StockStatus,
			&i.IsFeatured,
			&i.IsActive,
			&i.Media,
			&i.Attributes,
			&i.Specifications,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.OgImage,
			&i.Brand,
			&i.Tags,
			&i.WarrantyInfo,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
