// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: refunds.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRefund = `-- name: CreateRefund :one
INSERT INTO refunds (order_id, amount, reason, restock_items, created_by)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, order_id, amount, reason, restock_items, created_at, created_by
`

type CreateRefundParams struct {
	OrderID      pgtype.UUID    `json:"order_id"`
	Amount       pgtype.Numeric `json:"amount"`
	Reason       *string        `json:"reason"`
	RestockItems bool           `json:"restock_items"`
	CreatedBy    pgtype.UUID    `json:"created_by"`
}

func (q *Queries) CreateRefund(ctx context.Context, arg CreateRefundParams) (Refund, error) {
	row := q.db.QueryRow(ctx, createRefund,
		arg.OrderID,
		arg.Amount,
		arg.Reason,
		arg.RestockItems,
		arg.CreatedBy,
	)
	var i Refund
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.Amount,
		&i.Reason,
		&i.RestockItems,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getRefundsByOrderID = `-- name: GetRefundsByOrderID :many
SELECT r.id, r.order_id, r.amount, r.reason, r.restock_items, r.created_at, r.created_by, u.first_name as processed_by_name
FROM refunds r
LEFT JOIN users u ON u.id = r.created_by
WHERE r.order_id = $1
ORDER BY r.created_at DESC
`

type GetRefundsByOrderIDRow struct {
	ID              pgtype.UUID      `json:"id"`
	OrderID         pgtype.UUID      `json:"order_id"`
	Amount          pgtype.Numeric   `json:"amount"`
	Reason          *string          `json:"reason"`
	RestockItems    bool             `json:"restock_items"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	CreatedBy       pgtype.UUID      `json:"created_by"`
	ProcessedByName *string          `json:"processed_by_name"`
}

func (q *Queries) GetRefundsByOrderID(ctx context.Context, orderID pgtype.UUID) ([]GetRefundsByOrderIDRow, error) {
	rows, err := q.db.Query(ctx, getRefundsByOrderID, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRefundsByOrderIDRow{}
	for rows.Next() {
		var i GetRefundsByOrderIDRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.Amount,
			&i.Reason,
			&i.RestockItems,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.ProcessedByName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrderRefundedAmount = `-- name: UpdateOrderRefundedAmount :exec
UPDATE orders 
SET refunded_amount = refunded_amount + $2,
    payment_status = CASE 
        WHEN (refunded_amount + $2) >= paid_amount THEN 'refunded'
        ELSE 'partial_refund'
    END,
    status = CASE 
        WHEN (refunded_amount + $2) >= paid_amount THEN 'refunded'
        ELSE status
    END
WHERE id = $1
`

type UpdateOrderRefundedAmountParams struct {
	ID     pgtype.UUID    `json:"id"`
	Amount pgtype.Numeric `json:"amount"`
}

func (q *Queries) UpdateOrderRefundedAmount(ctx context.Context, arg UpdateOrderRefundedAmountParams) error {
	_, err := q.db.Exec(ctx, updateOrderRefundedAmount, arg.ID, arg.Amount)
	return err
}
