// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: orders.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const atomicRemoveCartItem = `-- name: AtomicRemoveCartItem :exec
DELETE FROM cart_items ci
USING carts c
WHERE ci.cart_id = c.id
  AND c.user_id = $1
  AND ci.product_id = $2
  AND ci.variant_id = $3
`

type AtomicRemoveCartItemParams struct {
	UserID    pgtype.UUID `json:"user_id"`
	ProductID pgtype.UUID `json:"product_id"`
	VariantID pgtype.UUID `json:"variant_id"`
}

func (q *Queries) AtomicRemoveCartItem(ctx context.Context, arg AtomicRemoveCartItemParams) error {
	_, err := q.db.Exec(ctx, atomicRemoveCartItem, arg.UserID, arg.ProductID, arg.VariantID)
	return err
}

const clearCart = `-- name: ClearCart :exec
DELETE FROM cart_items WHERE cart_id = $1
`

func (q *Queries) ClearCart(ctx context.Context, cartID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, clearCart, cartID)
	return err
}

const countOrders = `-- name: CountOrders :one
SELECT COUNT(*) 
FROM orders o
JOIN users u ON u.id = o.user_id
WHERE 
    ($1::text IS NULL OR o.status = $1) AND
    ($2::text IS NULL OR o.payment_status = $2) AND
    ($3::boolean IS NULL OR o.is_preorder = $3) AND
    ($4::text IS NULL OR 
        o.id::text ILIKE '%' || $4 || '%' OR 
        u.email ILIKE '%' || $4 || '%' OR 
        o.payment_details->>'transaction_id' ILIKE '%' || $4 || '%' OR
        o.payment_details->>'sender_number' ILIKE '%' || $4 || '%'
    )
`

type CountOrdersParams struct {
	Status        *string `json:"status"`
	PaymentStatus *string `json:"payment_status"`
	IsPreorder    *bool   `json:"is_preorder"`
	Search        *string `json:"search"`
}

func (q *Queries) CountOrders(ctx context.Context, arg CountOrdersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOrders,
		arg.Status,
		arg.PaymentStatus,
		arg.IsPreorder,
		arg.Search,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCart = `-- name: CreateCart :one
INSERT INTO carts (user_id) VALUES ($1) RETURNING id, user_id, created_at, updated_at
`

func (q *Queries) CreateCart(ctx context.Context, userID pgtype.UUID) (Cart, error) {
	row := q.db.QueryRow(ctx, createCart, userID)
	var i Cart
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (user_id, status, total_amount, shipping_fee, shipping_address, payment_method, payment_status, paid_amount, payment_details, is_preorder)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, user_id, status, total_amount, shipping_address, payment_method, payment_status, created_at, updated_at, paid_amount, payment_details, is_preorder, refunded_amount, shipping_fee
`

type CreateOrderParams struct {
	UserID          pgtype.UUID    `json:"user_id"`
	Status          string         `json:"status"`
	TotalAmount     pgtype.Numeric `json:"total_amount"`
	ShippingFee     pgtype.Numeric `json:"shipping_fee"`
	ShippingAddress []byte         `json:"shipping_address"`
	PaymentMethod   *string        `json:"payment_method"`
	PaymentStatus   *string        `json:"payment_status"`
	PaidAmount      pgtype.Numeric `json:"paid_amount"`
	PaymentDetails  []byte         `json:"payment_details"`
	IsPreorder      bool           `json:"is_preorder"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.UserID,
		arg.Status,
		arg.TotalAmount,
		arg.ShippingFee,
		arg.ShippingAddress,
		arg.PaymentMethod,
		arg.PaymentStatus,
		arg.PaidAmount,
		arg.PaymentDetails,
		arg.IsPreorder,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.TotalAmount,
		&i.ShippingAddress,
		&i.PaymentMethod,
		&i.PaymentStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PaidAmount,
		&i.PaymentDetails,
		&i.IsPreorder,
		&i.RefundedAmount,
		&i.ShippingFee,
	)
	return i, err
}

const createOrderHistory = `-- name: CreateOrderHistory :one
INSERT INTO order_history (order_id, previous_status, new_status, reason, created_by)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, order_id, previous_status, new_status, reason, created_by, created_at
`

type CreateOrderHistoryParams struct {
	OrderID        pgtype.UUID `json:"order_id"`
	PreviousStatus *string     `json:"previous_status"`
	NewStatus      string      `json:"new_status"`
	Reason         *string     `json:"reason"`
	CreatedBy      pgtype.UUID `json:"created_by"`
}

func (q *Queries) CreateOrderHistory(ctx context.Context, arg CreateOrderHistoryParams) (OrderHistory, error) {
	row := q.db.QueryRow(ctx, createOrderHistory,
		arg.OrderID,
		arg.PreviousStatus,
		arg.NewStatus,
		arg.Reason,
		arg.CreatedBy,
	)
	var i OrderHistory
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.PreviousStatus,
		&i.NewStatus,
		&i.Reason,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO order_items (order_id, product_id, variant_id, quantity, price)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, order_id, product_id, variant_id, quantity, price
`

type CreateOrderItemParams struct {
	OrderID   pgtype.UUID    `json:"order_id"`
	ProductID pgtype.UUID    `json:"product_id"`
	VariantID pgtype.UUID    `json:"variant_id"`
	Quantity  int32          `json:"quantity"`
	Price     pgtype.Numeric `json:"price"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRow(ctx, createOrderItem,
		arg.OrderID,
		arg.ProductID,
		arg.VariantID,
		arg.Quantity,
		arg.Price,
	)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductID,
		&i.VariantID,
		&i.Quantity,
		&i.Price,
	)
	return i, err
}

const getAllOrders = `-- name: GetAllOrders :many
SELECT o.id, o.user_id, o.status, o.total_amount, o.shipping_address, o.payment_method, o.payment_status, o.created_at, o.updated_at, o.paid_amount, o.payment_details, o.is_preorder, o.refunded_amount, o.shipping_fee, u.email, u.first_name, u.last_name
FROM orders o
JOIN users u ON u.id = o.user_id
WHERE 
    ($3::text IS NULL OR o.status = $3) AND
    ($4::text IS NULL OR o.payment_status = $4) AND
    ($5::boolean IS NULL OR o.is_preorder = $5) AND
    ($6::text IS NULL OR 
        o.id::text ILIKE '%' || $6 || '%' OR 
        u.email ILIKE '%' || $6 || '%' OR 
        o.payment_details->>'transaction_id' ILIKE '%' || $6 || '%' OR
        o.payment_details->>'sender_number' ILIKE '%' || $6 || '%'
    )
ORDER BY o.created_at DESC
LIMIT $1 OFFSET $2
`

type GetAllOrdersParams struct {
	Limit         int32   `json:"limit"`
	Offset        int32   `json:"offset"`
	Status        *string `json:"status"`
	PaymentStatus *string `json:"payment_status"`
	IsPreorder    *bool   `json:"is_preorder"`
	Search        *string `json:"search"`
}

type GetAllOrdersRow struct {
	ID              pgtype.UUID      `json:"id"`
	UserID          pgtype.UUID      `json:"user_id"`
	Status          string           `json:"status"`
	TotalAmount     pgtype.Numeric   `json:"total_amount"`
	ShippingAddress []byte           `json:"shipping_address"`
	PaymentMethod   *string          `json:"payment_method"`
	PaymentStatus   *string          `json:"payment_status"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	UpdatedAt       pgtype.Timestamp `json:"updated_at"`
	PaidAmount      pgtype.Numeric   `json:"paid_amount"`
	PaymentDetails  []byte           `json:"payment_details"`
	IsPreorder      bool             `json:"is_preorder"`
	RefundedAmount  pgtype.Numeric   `json:"refunded_amount"`
	ShippingFee     pgtype.Numeric   `json:"shipping_fee"`
	Email           string           `json:"email"`
	FirstName       *string          `json:"first_name"`
	LastName        *string          `json:"last_name"`
}

func (q *Queries) GetAllOrders(ctx context.Context, arg GetAllOrdersParams) ([]GetAllOrdersRow, error) {
	rows, err := q.db.Query(ctx, getAllOrders,
		arg.Limit,
		arg.Offset,
		arg.Status,
		arg.PaymentStatus,
		arg.IsPreorder,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllOrdersRow{}
	for rows.Next() {
		var i GetAllOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.TotalAmount,
			&i.ShippingAddress,
			&i.PaymentMethod,
			&i.PaymentStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PaidAmount,
			&i.PaymentDetails,
			&i.IsPreorder,
			&i.RefundedAmount,
			&i.ShippingFee,
			&i.Email,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCartByUserID = `-- name: GetCartByUserID :one
SELECT id, user_id, created_at, updated_at FROM carts WHERE user_id = $1
`

func (q *Queries) GetCartByUserID(ctx context.Context, userID pgtype.UUID) (Cart, error) {
	row := q.db.QueryRow(ctx, getCartByUserID, userID)
	var i Cart
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCartItemByProductID = `-- name: GetCartItemByProductID :one
SELECT id, cart_id, product_id, variant_id, quantity FROM cart_items WHERE cart_id = $1 AND product_id = $2
`

type GetCartItemByProductIDParams struct {
	CartID    pgtype.UUID `json:"cart_id"`
	ProductID pgtype.UUID `json:"product_id"`
}

func (q *Queries) GetCartItemByProductID(ctx context.Context, arg GetCartItemByProductIDParams) (CartItem, error) {
	row := q.db.QueryRow(ctx, getCartItemByProductID, arg.CartID, arg.ProductID)
	var i CartItem
	err := row.Scan(
		&i.ID,
		&i.CartID,
		&i.ProductID,
		&i.VariantID,
		&i.Quantity,
	)
	return i, err
}

const getCartItems = `-- name: GetCartItems :many
SELECT ci.id, ci.cart_id, ci.product_id, ci.variant_id, ci.quantity, p.name, p.slug, p.base_price, p.sale_price, p.media, v.stock, v.sku
FROM cart_items ci
JOIN products p ON p.id = ci.product_id
JOIN variants v ON v.id = ci.variant_id
WHERE ci.cart_id = $1
`

type GetCartItemsRow struct {
	ID        pgtype.UUID    `json:"id"`
	CartID    pgtype.UUID    `json:"cart_id"`
	ProductID pgtype.UUID    `json:"product_id"`
	VariantID pgtype.UUID    `json:"variant_id"`
	Quantity  int32          `json:"quantity"`
	Name      string         `json:"name"`
	Slug      string         `json:"slug"`
	BasePrice pgtype.Numeric `json:"base_price"`
	SalePrice pgtype.Numeric `json:"sale_price"`
	Media     []byte         `json:"media"`
	Stock     int32          `json:"stock"`
	Sku       *string        `json:"sku"`
}

func (q *Queries) GetCartItems(ctx context.Context, cartID pgtype.UUID) ([]GetCartItemsRow, error) {
	rows, err := q.db.Query(ctx, getCartItems, cartID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCartItemsRow{}
	for rows.Next() {
		var i GetCartItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.CartID,
			&i.ProductID,
			&i.VariantID,
			&i.Quantity,
			&i.Name,
			&i.Slug,
			&i.BasePrice,
			&i.SalePrice,
			&i.Media,
			&i.Stock,
			&i.Sku,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCartWithItems = `-- name: GetCartWithItems :many
SELECT 
    c.id as cart_id,
    c.user_id,
    ci.id as item_id,
    ci.product_id,
    ci.variant_id,
    ci.quantity,
    p.name,
    p.slug,
    p.base_price,
    p.sale_price,
    p.media,
    p.stock_status,
    v.stock,
    v.sku as variant_sku,
    v.name as variant_name,
    v.images as variant_images,
    v.price as variant_price,
    v.sale_price as variant_sale_price
FROM carts c
LEFT JOIN cart_items ci ON c.id = ci.cart_id
LEFT JOIN products p ON ci.product_id = p.id
LEFT JOIN variants v ON ci.variant_id = v.id
WHERE c.user_id = $1
`

type GetCartWithItemsRow struct {
	CartID           pgtype.UUID    `json:"cart_id"`
	UserID           pgtype.UUID    `json:"user_id"`
	ItemID           pgtype.UUID    `json:"item_id"`
	ProductID        pgtype.UUID    `json:"product_id"`
	VariantID        pgtype.UUID    `json:"variant_id"`
	Quantity         *int32         `json:"quantity"`
	Name             *string        `json:"name"`
	Slug             *string        `json:"slug"`
	BasePrice        pgtype.Numeric `json:"base_price"`
	SalePrice        pgtype.Numeric `json:"sale_price"`
	Media            []byte         `json:"media"`
	StockStatus      *string        `json:"stock_status"`
	Stock            *int32         `json:"stock"`
	VariantSku       *string        `json:"variant_sku"`
	VariantName      *string        `json:"variant_name"`
	VariantImages    []string       `json:"variant_images"`
	VariantPrice     pgtype.Numeric `json:"variant_price"`
	VariantSalePrice pgtype.Numeric `json:"variant_sale_price"`
}

func (q *Queries) GetCartWithItems(ctx context.Context, userID pgtype.UUID) ([]GetCartWithItemsRow, error) {
	rows, err := q.db.Query(ctx, getCartWithItems, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCartWithItemsRow{}
	for rows.Next() {
		var i GetCartWithItemsRow
		if err := rows.Scan(
			&i.CartID,
			&i.UserID,
			&i.ItemID,
			&i.ProductID,
			&i.VariantID,
			&i.Quantity,
			&i.Name,
			&i.Slug,
			&i.BasePrice,
			&i.SalePrice,
			&i.Media,
			&i.StockStatus,
			&i.Stock,
			&i.VariantSku,
			&i.VariantName,
			&i.VariantImages,
			&i.VariantPrice,
			&i.VariantSalePrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT id, user_id, status, total_amount, shipping_address, payment_method, payment_status, created_at, updated_at, paid_amount, payment_details, is_preorder, refunded_amount, shipping_fee FROM orders WHERE id = $1
`

func (q *Queries) GetOrderByID(ctx context.Context, id pgtype.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderByID, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.TotalAmount,
		&i.ShippingAddress,
		&i.PaymentMethod,
		&i.PaymentStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PaidAmount,
		&i.PaymentDetails,
		&i.IsPreorder,
		&i.RefundedAmount,
		&i.ShippingFee,
	)
	return i, err
}

const getOrderHistory = `-- name: GetOrderHistory :many
SELECT oh.id, oh.order_id, oh.previous_status, oh.new_status, oh.reason, oh.created_by, oh.created_at, u.first_name, u.last_name, u.email
FROM order_history oh
LEFT JOIN users u ON u.id = oh.created_by
WHERE oh.order_id = $1
ORDER BY oh.created_at DESC
`

type GetOrderHistoryRow struct {
	ID             pgtype.UUID        `json:"id"`
	OrderID        pgtype.UUID        `json:"order_id"`
	PreviousStatus *string            `json:"previous_status"`
	NewStatus      string             `json:"new_status"`
	Reason         *string            `json:"reason"`
	CreatedBy      pgtype.UUID        `json:"created_by"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	FirstName      *string            `json:"first_name"`
	LastName       *string            `json:"last_name"`
	Email          *string            `json:"email"`
}

func (q *Queries) GetOrderHistory(ctx context.Context, orderID pgtype.UUID) ([]GetOrderHistoryRow, error) {
	rows, err := q.db.Query(ctx, getOrderHistory, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderHistoryRow{}
	for rows.Next() {
		var i GetOrderHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.PreviousStatus,
			&i.NewStatus,
			&i.Reason,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderItems = `-- name: GetOrderItems :many
SELECT oi.id, oi.order_id, oi.product_id, oi.variant_id, oi.quantity, oi.price, p.name, p.slug, p.media, v.name as variant_name, v.sku as variant_sku
FROM order_items oi
JOIN products p ON p.id = oi.product_id
LEFT JOIN variants v ON v.id = oi.variant_id
WHERE oi.order_id = $1
`

type GetOrderItemsRow struct {
	ID          pgtype.UUID    `json:"id"`
	OrderID     pgtype.UUID    `json:"order_id"`
	ProductID   pgtype.UUID    `json:"product_id"`
	VariantID   pgtype.UUID    `json:"variant_id"`
	Quantity    int32          `json:"quantity"`
	Price       pgtype.Numeric `json:"price"`
	Name        string         `json:"name"`
	Slug        string         `json:"slug"`
	Media       []byte         `json:"media"`
	VariantName *string        `json:"variant_name"`
	VariantSku  *string        `json:"variant_sku"`
}

func (q *Queries) GetOrderItems(ctx context.Context, orderID pgtype.UUID) ([]GetOrderItemsRow, error) {
	rows, err := q.db.Query(ctx, getOrderItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderItemsRow{}
	for rows.Next() {
		var i GetOrderItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.VariantID,
			&i.Quantity,
			&i.Price,
			&i.Name,
			&i.Slug,
			&i.Media,
			&i.VariantName,
			&i.VariantSku,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByUserID = `-- name: GetOrdersByUserID :many
SELECT id, user_id, status, total_amount, shipping_address, payment_method, payment_status, created_at, updated_at, paid_amount, payment_details, is_preorder, refunded_amount, shipping_fee FROM orders WHERE user_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetOrdersByUserID(ctx context.Context, userID pgtype.UUID) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrdersByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.TotalAmount,
			&i.ShippingAddress,
			&i.PaymentMethod,
			&i.PaymentStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PaidAmount,
			&i.PaymentDetails,
			&i.IsPreorder,
			&i.RefundedAmount,
			&i.ShippingFee,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasPurchasedProduct = `-- name: HasPurchasedProduct :one
SELECT EXISTS (
    SELECT 1
    FROM order_items oi
    JOIN orders o ON o.id = oi.order_id
    WHERE o.user_id = $1 
      AND oi.product_id = $2
      AND o.status = 'delivered'
)
`

type HasPurchasedProductParams struct {
	UserID    pgtype.UUID `json:"user_id"`
	ProductID pgtype.UUID `json:"product_id"`
}

func (q *Queries) HasPurchasedProduct(ctx context.Context, arg HasPurchasedProductParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasPurchasedProduct, arg.UserID, arg.ProductID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateOrderPaymentStatus = `-- name: UpdateOrderPaymentStatus :exec
UPDATE orders SET payment_status = $2 WHERE id = $1
`

type UpdateOrderPaymentStatusParams struct {
	ID            pgtype.UUID `json:"id"`
	PaymentStatus *string     `json:"payment_status"`
}

func (q *Queries) UpdateOrderPaymentStatus(ctx context.Context, arg UpdateOrderPaymentStatusParams) error {
	_, err := q.db.Exec(ctx, updateOrderPaymentStatus, arg.ID, arg.PaymentStatus)
	return err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :exec
UPDATE orders SET status = $2 WHERE id = $1
`

type UpdateOrderStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) error {
	_, err := q.db.Exec(ctx, updateOrderStatus, arg.ID, arg.Status)
	return err
}

const upsertCartItemAtomic = `-- name: UpsertCartItemAtomic :many
WITH 
  user_cart AS (
    SELECT c.id FROM carts c
    WHERE c.id = $1 AND c.user_id = $2
  ),
  stock_valid AS (
    SELECT v.id FROM variants v
    JOIN products p ON p.id = v.product_id
    WHERE v.id = $3
      AND (v.stock >= $4 OR p.stock_status = 'pre_order')
      AND p.is_active = TRUE
  ),
  existing_item AS (
    SELECT ci.id FROM cart_items ci
    WHERE ci.cart_id = $1
      AND ci.product_id = $5
      AND (ci.variant_id IS NOT DISTINCT FROM $3)
  ),
  updated AS (
    UPDATE cart_items SET quantity = $4
    WHERE id = (SELECT id FROM existing_item)
      AND EXISTS (SELECT 1 FROM stock_valid)
    RETURNING id, cart_id, product_id, variant_id, quantity
  ),
  inserted AS (
    INSERT INTO cart_items (cart_id, product_id, variant_id, quantity)
    SELECT uc.id, $5, $3, $4
    FROM user_cart uc
    CROSS JOIN stock_valid sv
    WHERE NOT EXISTS (SELECT 1 FROM existing_item)
    RETURNING id, cart_id, product_id, variant_id, quantity
  ),
  results AS (
    SELECT id, cart_id, product_id, variant_id, quantity FROM updated
    UNION ALL
    SELECT id, cart_id, product_id, variant_id, quantity FROM inserted
  )
SELECT r.id, r.cart_id, r.product_id, r.variant_id, r.quantity,
       p.name, p.slug, p.base_price, p.sale_price, p.media, v.stock, v.sku as variant_sku, v.name as variant_name, v.images as variant_images,
       v.price as variant_price, v.sale_price as variant_sale_price
FROM results r
JOIN products p ON p.id = r.product_id
JOIN variants v ON v.id = r.variant_id
`

type UpsertCartItemAtomicParams struct {
	CartID    pgtype.UUID `json:"cart_id"`
	UserID    pgtype.UUID `json:"user_id"`
	VariantID pgtype.UUID `json:"variant_id"`
	Quantity  int32       `json:"quantity"`
	ProductID pgtype.UUID `json:"product_id"`
}

type UpsertCartItemAtomicRow struct {
	ID               pgtype.UUID    `json:"id"`
	CartID           pgtype.UUID    `json:"cart_id"`
	ProductID        pgtype.UUID    `json:"product_id"`
	VariantID        pgtype.UUID    `json:"variant_id"`
	Quantity         int32          `json:"quantity"`
	Name             string         `json:"name"`
	Slug             string         `json:"slug"`
	BasePrice        pgtype.Numeric `json:"base_price"`
	SalePrice        pgtype.Numeric `json:"sale_price"`
	Media            []byte         `json:"media"`
	Stock            int32          `json:"stock"`
	VariantSku       *string        `json:"variant_sku"`
	VariantName      string         `json:"variant_name"`
	VariantImages    []string       `json:"variant_images"`
	VariantPrice     pgtype.Numeric `json:"variant_price"`
	VariantSalePrice pgtype.Numeric `json:"variant_sale_price"`
}

// L9 FIX: Simplified atomic upsert without expression-based conflict target
func (q *Queries) UpsertCartItemAtomic(ctx context.Context, arg UpsertCartItemAtomicParams) ([]UpsertCartItemAtomicRow, error) {
	rows, err := q.db.Query(ctx, upsertCartItemAtomic,
		arg.CartID,
		arg.UserID,
		arg.VariantID,
		arg.Quantity,
		arg.ProductID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UpsertCartItemAtomicRow{}
	for rows.Next() {
		var i UpsertCartItemAtomicRow
		if err := rows.Scan(
			&i.ID,
			&i.CartID,
			&i.ProductID,
			&i.VariantID,
			&i.Quantity,
			&i.Name,
			&i.Slug,
			&i.BasePrice,
			&i.SalePrice,
			&i.Media,
			&i.Stock,
			&i.VariantSku,
			&i.VariantName,
			&i.VariantImages,
			&i.VariantPrice,
			&i.VariantSalePrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
